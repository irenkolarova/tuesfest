import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from picamera2 import MappedArray
from password import ivan_password
import RPi.GPIO as GPIO
import cv2
import libcamera
from picamera2 import MappedArray, Picamera2, Preview
from picamera2.encoders import H264Encoder
import time

def close(self):
    if self._preview is not None:
        self._preview.close()

    face_detector = cv2.CascadeClassifier("/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml")
    GPIO.setmode(GPIO.BOARD)

    TRIG_PIN = 40
    ECHO_PIN = 38
    GPIO.setup(TRIG_PIN, GPIO.OUT)
    GPIO.setup(ECHO_PIN, GPIO.IN)

    bachkai = 1

    def measure_distance():
        # send a pulse to the ultrasonic sensor
        GPIO.output(TRIG_PIN, GPIO.HIGH)
        time.sleep(0.00001)
        GPIO.output(TRIG_PIN, GPIO.LOW)
     
        # measure the time it takes for the echo to return
        start_time = time.time()
        while GPIO.input(ECHO_PIN) == GPIO.LOW:
            if (time.time() - start_time) > 0.1:
                return -1
        pulse_start = time.time()
        while GPIO.input(ECHO_PIN) == GPIO.HIGH:
            if (time.time() - start_time) > 0.1:
                return -1
        pulse_end = time.time()
     
        # calculate the distance based on the time it took for the echo to return
        pulse_duration = pulse_end - pulse_start
        distance = pulse_duration * 17150
        distance = round(distance, 2)
     
        return distance
        
    dis1 = measure_distance()

    while(bachkai==1):
        dis = measure_distance()
        if(dis!=dis1):
            bachkai = 0

    GPIO.cleanup()

    if(bachkai==0):
        # Set up email information
        sender_email = 'ivan.g.genov.2021@elsys-bg.org'
        sender_password = ivan_password
        recipient_email = 'gixirobot@gmail.com'
        subject = 'Person detected'
        body = 'A person has been detected in the video stream.'

        # Create SMTP session
        smtp_server = smtplib.SMTP('smtp.gmail.com', 587)
        smtp_server.starttls()
        smtp_server.login(sender_email, sender_password)
        
        
        def draw_faces(request):
            global faces
            with MappedArray(request, "main") as m:
                for f in faces:
                    (x, y, w, h) = [c * n // d for c, n, d in zip(f, (w0, h0) * 2, (w1, h1) * 2)]
                    cv2.rectangle(m.array, (x, y), (x + w, y + h), (0, 255, 0, 0))
                    
                    # Stop recording and capture image
                    picam2.stop_recording()
                    img = m.array.copy()
                    cv2.imwrite('capture.jpg', img)
                    
                    # Send email with image attached
                    with open('capture.jpg', 'rb') as f:
                        img_data = f.read()
                    message = MIMEMultipart()
                    message['From'] = sender_email
                    message['To'] = recipient_email
                    message['Subject'] = subject
                    message.attach(MIMEImage(img_data))
                    smtp_server.sendmail(sender_email, recipient_email, message.as_string())
                    time.sleep(1)

        faces = []

        # Create camera object
        picam2 = Picamera2()
        picam2.set_resolution(640, 480)
        picam2.framerate = 24

        # Create preview and start recording
        preview = Preview(picam2, size=(320, 240), position=(0, 0), layer=0)
        encoder = H264Encoder(picam2)
        encoder.start(output="/dev/null")

        # Set up variables for face detection
        faces = []
        min_face_size = (50, 50)
        scale_factor = 1.2
        min_neighbors = 5
        flags = cv2.CASCADE_SCALE_IMAGE

        # Start loop for capturing frames and detecting faces
        while True:
            try:
                # Capture a frame from the camera
                frame = encoder.frame(timeout=10)
                if frame is None:
                    continue

                # Convert frame to grayscale and detect faces
                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                gray = cv2.equalizeHist(gray)
                faces = face_detector.detectMultiScale(gray, scaleFactor=scale_factor, minNeighbors=min_neighbors, minSize=min_face_size, flags=flags)

                # Draw rectangles around detected faces and capture image if a face is detected
                if len(faces) > 0:
                    draw_faces(frame)
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
                continue


        # Clean up GPIO and close SMTP session
        GPIO.cleanup()
        smtp_server.quit()